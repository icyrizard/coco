\documentclass[a4paper]{article}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{makeidx}
\marginparsep = 10pt
\author{Rik van der Kooij - 6064965\\
Richard Torenvliet - 6138861}
\title{Compiler Construction - Creating the CiViC Compiler}
\begin{document}
\lstset{
    numbers=left,
    tabsize=2,
}


\tableofcontents
\maketitle
\abstract{Civicc Compiler}
\section{Introduction}
This document describes yet another implementation of the CiviC compiler for
the CiviC-VM. The creation of the CiviC compiler consists of different phases
in order to parse the program text to assembly which in turn the CiviC-VM can
interpret. The CiviC language has a C-like structure. By implementing this
compiler all the steps that involve to create a compiler can be learned.
Because CiviC takes use of the CiviC-VM, we do not have to worry about
different architectures the program runs on. To aid in the creation of the
compiler, we take use of the framework provided. The framework provides
functionalities to create phases, generated node creation functions and helper
functions that we can use to operate on Strings.

A starting point is defining the AST(Abstract Syntax Tree), which
describes the hierarchy of "Nodes", the actual definition of the AST is stated
in Backus Nauer form in the CiviC Language Manuel. The next step is creating the Lex and Yacc to parse a
file and assemble the AST. This AST is used in the next phases like "desugaring", "type checking" and "code generation". These phases are explained in the following sections.

\section{Abstract Syntax Tree}
An abstract syntaxtree is a representation of the structure of components that
are involved in the definition of a language.
The abstract syntaxtree is represented in XML form. In the XML
file(\texttt{src/global/ast.xml}) the hierarchy and relation between nodes can
be expressed. To implement the CiviC language, the CiviC reference manual has
to be carefully followed. The language is defined in Backus Nauer form which is
turned in to XML that follows a certain syntax in order to describe the tree.
For example, an assign node(see reference document) is described by the
following.

\begin{lstlisting}[language=XML]
 <node name="Assign">
  <sons>
    <son name="Let">
      <targets>
        <target mandatory="yes">
          <node name="Var" />
          <phases>
            <all />
          </phases>
        </target>
      </targets>
    </son>
    <son name="Expr">
      <targets>
        <target mandatory="yes">
          <set name="Expr" />
          <phases>
            <all />
          </phases>
        </target>
      </targets>
    </son>
  </sons>
  <attributes />
</node>
\end{lstlisting}

An important thing to note is that <sons> represent other nodes in the ast.xml,
and a relation between these nodes is created. To create a cyclic
relation(needed for lists, e.g statement lists), the node that is referred to can refer back to the parent node.

Also, if a node is a ctype, those are described in the \texttt{<attributes>} field.\\
\texttt{<type name="String" ctype="char*" init="NULL" copy="function" />}
\\
The AST can be visually represented in a Directed Cyclic Graph, the resulting
tree can be seen in figure \ref{fig:ast.png}.

\begin{figure}[h!]
    \includegraphics[width=15cm]{../framework/doc/ast.png}
\label{fig:ast.png}
\caption{The resulting AST}
\end{figure}

The framework generates functions to create these nodes which can be
used in the Yaccer matches sequence of tokens to nodes. To construct the AST in memory. Which then can be used to
perform semantically check the code. The functions that are generated also
follow a specific syntax:\\
\texttt{TBmake<NODENAME>\_<SON\_NAME/ATTRIBUTE\_NAME>}

\section{Lex and Yacc}
This phase forms the base of the compiler. The first step is to do a lexical
analysis with Lex, it matches a sequence of characters that form will form a
token, also non allowed characters are detected. A tokenstream is generated
form the code and are provided to the Yaccer, a sequence of these map to a certain node(exactly the nodes we
described in the ast.xml and the CiviC reference). If a successful match is
found, the according \texttt{TBmake..(\$1, \$2, \$3)} function is called. The
matched tokens are used as parameters. Then end result will be the complete AST
in memory.

\section{Phases and Traversing}
The framework provides ways to add compiler phases to the process. First,
adding the phase to \texttt{src/global/myphases.mac}, then adding a new folder
in \texttt{src/} which corresponds to the name of the phase. In
\texttt{Makefile.Targets} the name of the object file needs to added, the
framework will then compile the new phase. The phases are executed one after
the other in the order of which they are placed in \texttt{src/global/phase.mac}.

Traversing the tree is an important aspect to target nodes, e.g rewriting for
loops in to while loops will only target the while nodes. Which nodes are
targeted in a phase is defined in the \texttt{ast.xml}, also nodes that we
should not traverse can be expressed.

The framework performs functioncalls which are also constrained to a specific
syntax: \texttt{<PHASENAME><nodename>(arg *node, info *node);}. The arg is the
node type that we want to traverse. In a lot of cases the program needs to
alter or traverse a node inside the given node. For that the framework provides
macros to extract this data. Which follow the following syntax:
\texttt{<NODENAME>\_<NODEFIELD>(*node)}.

The info node object is used to communicate between these functions. It can be
used to contain anything to create a state of the current traversal phase. The
following sections explain the usage of this object if needed.

\section{Desugaring}
Due to the fact that new declarations and initializations of variables are not
always possible, these need to rewritten to a separate declaration or separate
initialization.

\subsection{Global variables to \_\_init}
The first desugaring step is to rewrite the initialization of global variables
to a new \_\_init function, this is in fact "code generation". The reason for
this is that ultimately the assembly instructions need to be placed under a
label/function. In addition the global variables need to initialized before any
other instruction is invoked, simply because of the fact that we expect them to
hold the right variable before anything else.

This phase does imply that the \_\_init function is called first by the
CiviC-VM and secondly that \_\_init can not be declared by the user.
The node of interest is the \texttt{GlobalDef}, which is defined in the CiviC
manual by:\\
\textit{GlobalDef $\Rightarrow$ [ \texttt{export} ] Type Id [ = Expr ]}

In the event of an Expr, which means that an assignment is present. A new
assignment expression is created and prepended to a list in the info object.
The list of new assign nodes is added in the end to a new function called
\_\_init. See psuedo code in figure \ref{fig:init}.

\begin{figure}[h]
    \begin{lstlisting}[language=C, frame=single]
    info = {
        list *globaldefs;
    };

    INITglobaldef (arg, info){
        /* return if no assignment*/
        if arg->expr:
            return

        /* store a new expression node */
        info->globaldefs.prepend(new_expr_node);

        /* remove the assignment */
        arg->expr = NULL;
    }

    /* add init to top of statements */
    add_init(info);
    \end{lstlisting}
    \caption{Globaldefs to \_\_init}
    \label{fig:init}
\end{figure}

\subsection{Forloop variable initialization desuggering}
All forloops start with a declaration part. This part will be split from the
for loop much like we did with the global variables. The declaration of the
loop variables is moved to the top of the function. The loop variables could be
seen as though they are defined in a different scope. This means that we had to
rename it to allow multiple local variables of the same name.

We used a list to collect all new variable declarations and a hashmap which
consisted of 'rewrite rules'. The rewrite rules were simply the old variable
name and the new one. Whith this we were able to rename all uses of forloop
variables with the new name.

\section{Semantic Analysis}
Semantic analysis is where we add semantic information and check whether or not
the given program is valid. After this phase the program should be valid and no
further checking should be needed.

\subsection{Context Analysis}
Before we can do any type checking we should have a convinient way to get the
type of an identifier. This is what we are going to do by linking each
identifier with its declaration.

Declarations of variables should always come before the use. This makes linking
fairly easy. Each time we find a new declaration we store it either in a list
for global or local variables. When a variable is being used we simply get the
declaration from the list. Duplicate declarations or missing declarations will
be reported.

Functions on the other hand can be used before their declaration. For this we
simply kept track of all function calls where we didn't see a declaration for
yet. Opon reaching a declaration we would link all stored function calls. Error
messages of non declared function calls is done at the end.

\subsection{Type Checking}
Type checking makes sure that all functions and operations are applied to the
correct types. The implementation rests on the last phase which makes it able
to get the type of the identifiers. This way we can throw the type upwards when
we traversing the tree. In ever traversal of a node we can simply traverse the
children and get their types. When we have the types of the children it is
mererly checking whether or not the types are ok.

\subsection{Loop Rewriting}
We made a little phase to rewrite do while and for loops to while loops. As we
thought it might make the rest of the code easier. do while loops simply have
their body copied above the new while loop and for loops are have their
initialization above the while and the increment at the end of the loop


\subsection{Conjunction and Disjunction replacement}
In this phase we rewrite the logic conjunction and disjunction to branches. One
of the rewrites looked as follows:
\begin{lstlisting}[language=C]
/* from this */
var = expr && expr

/* to this */
temp = expr
if(temp)
    temp = expr
var = temp
\end{lstlisting}

If we take line 8 to be our old statement we only have to change the expression
of the assignment and create new statements above it. This is a problem since
the statement list can only been traversed fowards. Once arrived at a statement you can't go
back. Which in turn means you an only append statements after the current one.

We tackled this by not picking line 8, but line 5 as our old statement. Replacing
both the let and expression of the assignment. We can then easily insert the
other three statements to the statment list.

\section{Code Generation}
In the code the last three phases (code generation, peephole optimization and
assembly printing) are put in one file. This was unfortunately due to time
constraints. It made our lives a little easier as we did not have to worry
about passing the assembly instructions to a new phase.

%TODO: we gebruiken voor elke assembly onderdeel een lijst (instr, import, ..)
The civic assembly can be described as a list of instructions followed by
a global variable, a constant, an import and an export table. In our code each
of these will be represented as a list which are filled when traversing the syntax tree.


%TODO: instructies maken we zo!



\section{Peephole Optimization}
Our peepholer looks at two instructions at the time. We optimize a consecutive
load and store to the same register by removing both instructions.
Another optimization is done by changing 'load 0' to 'load\_0'

%TODO als je nog iets weet


\section{Conclusion}
%TODO Awesome conclusie


\section{List and HashMap}
A list data structure with an dynamic size would help out alot. An example
would be in  desuggaring of for loops where all new vardecs could then be
stored in that list. We created our own linked list implementation in the file:
'framework/src/framework/list\_hash.c'. All function names should be enough to
indicate what they are doing.

Another usefull data structure would be an hash map. We also created a simple
hash map implementation in the same file as the linked list. The hash map can
be used to create simple rename rules for variables. For example for loop
desugaring requires to rename all loop variables. In the hash map we can use
the key for the old value for lookup and the value for the new value.



%TODO Er moet ook ergens nog komen dat we nested functies en arrays niet
%     hebben.


\end{document}
